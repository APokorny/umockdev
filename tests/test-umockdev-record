#!/usr/bin/python3

'''umockdev-record tests'''

__copyright__ = 'Copyright (C) 2012-2013 Canonical Ltd.'
__author__ = 'Martin Pitt <martin.pitt@ubuntu.com>'

# umockdev is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# umockdev is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

import os
import os.path
import sys
import subprocess
import unittest
import tempfile

from gi.repository import UMockdev

rootdir = os.environ.get('TOP_BUILDDIR', os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
umockdev_record_path = os.path.join(rootdir, 'src', 'umockdev-record')

def call(args):
    '''Call umockdev-record with given arguments.

    Return (code, stdout, stderr) tuple.
    '''
    umockdev_record = subprocess.Popen([umockdev_record_path] + args,
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE,
                                 universal_newlines=True)
    (out, err) = umockdev_record.communicate()
    out = out.strip()
    err = err.strip()
    return (umockdev_record.returncode, out, err)

class Testbed(unittest.TestCase):
    def setUp(self):
        self.testbed = UMockdev.Testbed.new()

    def test_all_empty(self):
        '''--all on empty testbed'''

        (code, out, err) = call(['--all'])
        self.assertEqual(err, '')
        self.assertEqual(out, '')
        self.assertEqual(code, 0)

    def test_one(self):
        '''one device'''

        syspath = self.testbed.add_device(
            'pci', 'dev1', None,
            ['simple_attr', '1', 'multiline_attr', 'a\\b\nc\\d\nlast'],
            ['SIMPLE_PROP', '1'])
        self.testbed.set_attribute_binary(syspath, 'binary_attr', b'\x41\xFF\x00\x05\xFF\x00')

        (code, out, err) = call([syspath])
        self.assertEqual(err, '')
        self.assertEqual(code, 0)
        self.assertEqual(out, '''P: /devices/dev1
E: SIMPLE_PROP=1
E: SUBSYSTEM=pci
H: binary_attr=41FF0005FF00
A: multiline_attr=a\\\\b\\nc\\\\d\\nlast
A: simple_attr=1''')

    def test_multiple(self):
        '''multiple devices'''

        dev1 = self.testbed.add_device(
            'pci', 'dev1', None, ['dev1color', 'green'], ['DEV1COLOR', 'GREEN'])
        subdev1 = self.testbed.add_device(
            'pci', 'subdev1', dev1, ['subdev1color', 'yellow'],
            ['SUBDEV1COLOR', 'YELLOW'])
        dev2 = self.testbed.add_device(
            'usb', 'dev2', None, ['dev2color', 'brown'], ['DEV2COLOR', 'BROWN'])

        # should grab device and all parents
        (code, out, err) = call([subdev1])
        self.assertEqual(err, '')
        self.assertEqual(code, 0)
        self.assertEqual(out, '''P: /devices/dev1/subdev1
E: SUBDEV1COLOR=YELLOW
E: SUBSYSTEM=pci
A: subdev1color=yellow

P: /devices/dev1
E: DEV1COLOR=GREEN
E: SUBSYSTEM=pci
A: dev1color=green''')

        (code, out, err) = call([dev1])
        self.assertEqual(err, '')
        self.assertEqual(code, 0)
        self.assertEqual(out, '''P: /devices/dev1
E: DEV1COLOR=GREEN
E: SUBSYSTEM=pci
A: dev1color=green''')

        # with --all it should have all three
        (code, out, err) = call(['--all'])
        self.assertEqual(err, '')
        self.assertEqual(code, 0)
        self.assertTrue('P: /devices/dev1/subdev1\n' in out, out)
        self.assertTrue('P: /devices/dev1\n' in out, out)
        self.assertTrue('P: /devices/dev2\n' in out, out)

    def test_no_ioctl_in_testbed(self):
        '''tracing ioctls does not work in testbed'''
        
        self.testbed.add_device('mem', 'zero', None, ['dev', '1:5'], [])

        (code, out, err) = call(['--ioctl', '/dev/stdout', '/sys/devices/zero', '--',
                                 'head', '-c1', '/dev/zero'])
        self.assertNotEqual(code, 0)
        self.assertEqual(out, '')
        self.assertTrue('UMOCKDEV_DIR cannot be used' in err, err)


@unittest.skipUnless(os.path.isdir('/sys/devices/system'), 'no /sys')
class System(unittest.TestCase):
    def test_all(self):
        '''system /sys: umockdev-record --all works and result loads back'''

        (code, out, err) = call(['--all'])
        self.assertEqual(err, '')
        self.assertEqual(code, 0)
        self.assertTrue(out.startswith('P:'), out[:100] + '[..]')
        self.assertGreater(len(out), 100, out[:100] + '[..]')

        testbed = UMockdev.Testbed.new()
        self.assertTrue(testbed.add_from_string(out))

    def test_ioctl_log(self):
        '''umockdev-record --ioctl recording to a file

        Note that this cannot test actual ioctls, as we cannot rely on an USB
        device which accepts the ioctls that we can handle; but we can at
        least ensure that the preload lib gets loaded, the log gets created,
        and recording happens on the right device.
        '''
        with tempfile.TemporaryDirectory() as tdir:
            log = os.path.join(tdir, 'log')
            # should not log anything, as that device is not touched
            (code, out, err) = call(['--ioctl', log, '/dev/null', '--',
                                     'head', '-c1', '/dev/zero'])
            self.assertEqual(code, 0)
            self.assertEqual(out, '\x00')
            self.assertEqual(err, '')
            self.assertFalse(os.path.exists(log))

            # this should create a log
            (code, out, err) = call(['--ioctl', log, '/dev/zero', '--',
                                     'head', '-c1', '/dev/zero'])
            self.assertEqual(code, 0)
            self.assertEqual(out, '\x00')
            self.assertEqual(err, '')
            self.assertEqual(os.path.getsize(log), 0)

unittest.main(testRunner=unittest.TextTestRunner(stream=sys.stdout, verbosity=2))
