#!/usr/bin/python3

'''Dump Linux devices and their ancestors from sysfs/udev.

All attributes and properties are included, non-ASCII ones get printed in hex.
The dump is written to the standard output.
'''

__copyright__ = "Copyright (C) 2012-2013 Canonical Ltd."
__author__ = "Martin Pitt <martin.pitt@ubuntu.com>"

# umockdev is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# umockdev is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

import argparse
import subprocess
import os
import stat
import sys
import errno
from gettext import gettext as _

_py2 = sys.version_info.major < 3

def fatal(msg):
    sys.stderr.write(msg)
    sys.stderr.write('\n')
    sys.exit(1)

def all_devices():
    devs = []
    for base, dirs, files in os.walk('/sys/devices'):
        if 'uevent' in files and 'subsystem' in dirs:
            devs.append(base)
    return devs

def parse_args():
    ap = argparse.ArgumentParser(
        description=_('Dump Linux devices and their ancestors from sysfs/udev, or record ioctls for a device.'))
    ap.add_argument('devices', metavar='DEVICE', nargs="*",
                    help=_('Path of a device in /dev or /sys.'))
    ap.add_argument('--all', '-a', action='store_true',
                    help=_('Dump all devices'))
    ap.add_argument('--ioctl', metavar='FILE',
                    help=_('Trace ioctls on the device, record into given file. In this case, the first argument specifies the device, and all remaining arguments are a command (and its arguments) to run that gets traced.'))

    args = ap.parse_args()

    if args.all and args.devices:
        ap.error(_('Specifying a device list together with --all is invalid.'))
    if not args.all and not args.devices:
        ap.error(_('Need to specify at least one device or --all.'))
    if args.ioctl and (args.all or len(args.devices) < 2):
        ap.error(_('For tracing ioctls you have to specify exactly one device and a command to run'))

    if args.all:
        args.devices = all_devices()

    return args

def resolve(dev):
    '''If dev is a block or character device, convert it to a sysfs path.'''
    try:
        st = os.stat(dev)
    except OSError as e:
        fatal(str(e))

    # character device?
    if stat.S_ISCHR(st.st_mode):
        link = '/sys/dev/char/%i:%i' % (os.major(st.st_rdev), os.minor(st.st_rdev))
    elif stat.S_ISBLK(st.st_mode):
        link = '/sys/dev/block/%i:%i' % (os.major(st.st_rdev), os.minor(st.st_rdev))
    else:
        link = dev

    if not os.path.exists(link):
        fatal('Cannot resolve device %s to a sysfs path, %s does not exist' % (dev, link))

    dev = os.path.realpath(link)
    if not os.path.exists(os.path.join(dev, 'uevent')):
        fatal('Invalid device %s, has no uevent attribute' % dev)

    return dev

def format_hex(value):
    '''Return hexadecimal representation of value'''

    text = ''
    if _py2:
        # Python 2 does not consider elements in byte strings as numbers
        for byte in value:
            text += '%02X' % ord(byte)
    else:
        for byte in value:
            text += '%02X' % byte
    return text

def format_attr(value):
    # first, try text
    try:
        text = value.decode('ASCII')
        # escape line breaks and backslashes
        if text.endswith('\n'):
            text = text[:-1]
        text = text.replace('\\', '\\\\')
        text = text.replace('\n', '\\n')
        return ('A', text)
    except UnicodeDecodeError:
        pass

    # something binary, encode as hex
    return ('H', format_hex(value))

# majors of devices for whom it's safe to read from:
# - USB (device descriptor)
_safe_majors = [189]

def dev_contents(dev):
    '''Return contents of device node, if applicable.'''

    try:
        st = os.stat(dev)
    except OSError:
        return ''
    # only attempt this for safe devices
    if not stat.S_ISCHR(st.st_mode) or os.major(st.st_rdev) not in _safe_majors:
        return ''
    try:
        # ignore if it is bigger than 1 KiB
        fd = os.open(dev, os.O_RDONLY | os.O_NONBLOCK)
        contents = os.read(fd, 1024)
        if os.read(fd, 1):
            return ''
    except OSError as e:
        #sys.stderr.write('%s: failed: %s\n' % (dev, str(e)))
        return ''

    return '=' + format_hex(contents)

def dump_device(dev):
    '''Dump a single device'''

    prop_blacklist = ['DEVPATH', 'UDEV_LOG', 'USEC_INITIALIZED']
    attr_blacklist = ['subsystem', 'firmware_node', 'driver', 'uevent']

    # we start with udevadm dump of this device, which will include all udev
    # properties
    udevadm = subprocess.Popen(['udevadm', 'info', '--query=all', '--path', dev], 
                               stdout=subprocess.PIPE, universal_newlines=True)
    out = udevadm.communicate()[0]
    # filter out redundant/uninteresting properties
    for line in out.splitlines():
        if not line:
            continue
        for bl in prop_blacklist:
            if line.startswith('E: %s=' % bl):
                break
        else:
            if line.startswith ('N: '):
                line += dev_contents('/dev/' + line[2:].strip())
            sys.stdout.write(line)
            sys.stdout.write('\n')

    # now append all attributes
    for attr_name in sorted(os.listdir(dev)):
        if attr_name in attr_blacklist:
            continue
        attr_path = os.path.join(dev, attr_name)
        # only look at files or symlinks
        if not os.path.isfile(attr_path):
            continue
        if os.path.islink(attr_path):
            sys.stdout.write('L: %s=%s\n' % (attr_name, os.readlink(attr_path)))
        else:
            try:
                with open(attr_path, 'rb') as f:
                    (cls, value) = format_attr(f.read())
            except IOError as e:
                # some attributes are EACCES, or "no such device", etc.
                continue
            sys.stdout.write('%s: %s=%s\n' % (cls, attr_name, value))

    sys.stdout.write('\n')

def parent(dev):
    '''Get a device's parent'''

    dev = os.path.dirname(dev)
    if not dev.startswith('/sys'):
        return None

    if os.path.exists(os.path.join(dev, 'uevent')) and os.path.exists(os.path.join(dev, 'subsystem')):
        return dev

    # we might have intermediate directories without uevent, so try the next
    # higher one
    return parent(dev)


def dump_ioctl(dev, outfile, argv):
    '''Dump ioctls for given device into outfile while running a command.'''

    # build device major/minor
    with open(os.path.join(dev, 'dev')) as f:
        (major, minor) = f.read().strip().split(':')
        dev = str((int(major) << 8) | int(minor))

    env = os.environ.copy()
    env['LD_PRELOAD'] = 'libumockdev-preload.so.0:' + env.get('LD_PRELOAD', '')
    env['UMOCKDEV_IOCTL_RECORD_FILE'] = outfile
    env['UMOCKDEV_IOCTL_RECORD_DEV'] = dev
    sys.exit(subprocess.call(argv, env=env))


#
# main
#

args = parse_args()

if args.ioctl:
    dump_ioctl(resolve(args.devices[0]), args.ioctl, args.devices[1:])
else:
    seen = set()
    for device in args.devices:
        while device:
            device = resolve(device)
            if device not in seen:
                seen.add(device)
                dump_device(device)
            device = parent(device)
