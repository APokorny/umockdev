#!/usr/bin/python3

'''Dump Linux devices and their ancestors from sysfs/udev.

All attributes and properties are included, non-ASCII ones get printed in hex.
The dump is written to the standard output.
'''

__copyright__ = "Copyright (C) 2012 Canonical Ltd."
__author__ = "Martin Pitt <martin.pitt@ubuntu.com>"

# umockdev is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# umockdev is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

import argparse
import subprocess
import os
import stat
import sys
import errno
from gettext import gettext as _

_py2 = sys.version_info.major < 3

def fatal(msg):
    sys.stderr.write(msg)
    sys.stderr.write('\n')
    sys.exit(1)

def all_devices():
    devs = []
    for base, dirs, files in os.walk('/sys/devices'):
        if 'uevent' in files:
            devs.append(base)
    return devs

def parse_args():
    ap = argparse.ArgumentParser(
        description=_('Dump Linux devices and their ancestors from sysfs/udev.'))
    ap.add_argument('devices', metavar='DEVICE', nargs="*",
                    help=_('Path of a device in /dev or /sys.'))
    ap.add_argument('--all', '-a', action='store_true',
                    help=_('Dump all devices'))

    args = ap.parse_args()

    if args.all and args.devices:
        ap.error(_('Specifying a device list together with --all is invalid.'))
    if not args.all and not args.devices:
        ap.error(_('Need to specify at least one device or --all.'))

    if args.all:
        args.devices = all_devices()

    return args

def resolve(dev):
    '''If dev is a block or character device, convert it to a sysfs path.'''
    try:
        st = os.stat(dev)
    except OSError as e:
        fatal(str(e))

    # character device?
    if stat.S_ISCHR(st.st_mode):
        link = '/sys/dev/char/%i:%i' % (os.major(st.st_rdev), os.minor(st.st_rdev))
    elif stat.S_ISBLK(st.st_mode):
        link = '/sys/dev/block/%i:%i' % (os.major(st.st_rdev), os.minor(st.st_rdev))
    else:
        link = dev

    if not os.path.exists(link):
        fatal('Cannot resolve device %s to a sysfs path, %s does not exist' % (dev, link))

    dev = os.path.realpath(link)
    if not os.path.exists(os.path.join(dev, 'uevent')):
        fatal('Invalid device %s, has no uevent attribute' % dev)

    return dev

def format_attr(value):
    # first, try text
    try:
        text = value.decode('ASCII')
        # escape line breaks and backslashes
        if text.endswith('\n'):
            text = text[:-1]
        text = text.replace('\\', '\\\\')
        text = text.replace('\n', '\\n')
        return ('A', text)
    except UnicodeDecodeError:
        pass

    # something binary, encode as hex
    text = ''
    if _py2:
        # Python 2 does not consider elements in byte strings as numbers
        for byte in value:
            text += '%02X' % ord(byte)
    else:
        for byte in value:
            text += '%02X' % byte
    return ('H', text)

def dump_device(dev):
    '''Dump a single device'''

    prop_blacklist = ['DEVPATH', 'UDEV_LOG', 'USEC_INITIALIZED']
    attr_blacklist = ['subsystem', 'firmware_node', 'driver', 'uevent']

    # we start with udevadm dump of this device, which will include all udev
    # properties
    udevadm = subprocess.Popen(['udevadm', 'info', '--query=all', '--path', dev], 
                               stdout=subprocess.PIPE, universal_newlines=True)
    out = udevadm.communicate()[0]
    # filter out redundant/uninteresting properties
    for line in out.splitlines():
        if not line:
            continue
        for bl in prop_blacklist:
            if line.startswith('E: %s=' % bl):
                break
        else:
            sys.stdout.write(line)
            sys.stdout.write('\n')

    # now append all attributes
    for attr_name in sorted(os.listdir(dev)):
        if attr_name in attr_blacklist:
            continue
        attr_path = os.path.join(dev, attr_name)
        # only look at files or symlinks
        if not os.path.isfile(attr_path):
            continue
        if os.path.islink(attr_path):
            sys.stdout.write('L: %s=%s\n' % (attr_name, os.readlink(attr_path)))
        else:
            try:
                with open(attr_path, 'rb') as f:
                    (cls, value) = format_attr(f.read())
            except IOError as e:
                # some attributes are EACCES, or "no such device", etc.
                continue
            sys.stdout.write('%s: %s=%s\n' % (cls, attr_name, value))

    sys.stdout.write('\n')

def parent(dev):
    '''Get a device's parent'''

    dev = os.path.dirname(dev)
    if not dev.startswith('/sys'):
        return None

    if os.path.exists(os.path.join(dev, 'uevent')):
        return dev

    # we might have intermediate directories without uevent, so try the next
    # higher one
    return parent(dev)

#
# main
#

args = parse_args()

for device in args.devices:
    while device:
        device = resolve(device)
        dump_device(device)
        device = parent(device)
